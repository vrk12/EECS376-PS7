The first step to my solution was to add functionality to the file traj_builder.cpp so that it creates the slowing down trajectory when a lidar alarm is received. Basically, I find the start pose and twist from the vec_of_states and save it to a variable called currentState. I then clear the vec_of_states.

I then determine whether the robot is spinning and/or moving forward by obtaining the current state's angular and linear twist values. If it is spinning, I decrease the desired omega gradually and the push_back that to the vec_of_states vector. If it is moving forward, I slow it's speed down gradually and then push_back that desired state to the vec_of_states as well.

In the pub_des_state.cpp file, I added a subscriber to my lidar alarm. If the lidar alarm is triggered while it is in the PURSUING_SUBGOAL mode, I basically have it so that it begins the build_braking_traj function from trajbuilder that I previously described. It also changes the mode to HALTING and resets the variable keeping track of the lidar alarm being triggered. This part is incomplete because I was unable to make it properly subscribe to the lidar alarm, which is why there is no video attached.
